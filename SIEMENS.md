SIEMENS

## 1.说说Scrum和XP敏捷开发的不同，为什么采用XP敏捷开发

**敏捷开发**(Agile Development)是一种以人为核心、迭代、循序渐进的开发方法。

怎么理解呢？首先，我们要理解它不是一门技术，它是一种开发方法，也就是一种软件开发的流程，它会指导我们用规定的环节去一步一步完成项目的开发；而这种开发方式的主要驱动核心是人；它采用的是迭代式开发；

**瀑布开发模型**，它是以文档为驱动的，为什么呢？因为在瀑布的整个开发过程中，要写大量的文档，把需求文档写出来后，开发人员都是根据文档进行开发的，一切以文档为依据；而敏捷开发它只写有必要的文档，或尽量少写文档，敏捷开发注重的是人与人之间，面对面的交流，所以它强调以人为核心。

**迭代**是指把一个复杂且开发周期很长的开发任务，分解为很多小周期可完成的任务，这样的一个周期就是一次迭代的过程；同时每一次迭代都可以生产或开发出一个可以交付的软件产品。

### Scrum和XP的区别

* Scrum偏重于过程，XP则偏重于实践，但是实际中，两者是结合一起应用的，这里我主要讲Scrum。
* 迭代周期不同，XP的一个Sprint的迭代长度大致为1~2周, 而Scrum的迭代长度一般为 2~ 4周.
* XP允许修改，Scrum不允许修改，并由Scrum Master严格把关
* User Story XP是务必要遵守优先级别的。 但Scrum在这点做得很灵活， 可以不按照优先级别来做
* Scrum没有对软件的整个实施过程开出工程实践的处方。要求开发者自觉保证，但XP对整个流程方法定义非常严格，规定需要采用TDD, 自动测试， 结对编程，简单设计，重构等约束团队的行为

Scrum：争球

产品负责人（Product Owner）

流程管理员（Scrum Master）

开发团队（Scrum Team）

## 2.谈一下贪心和动态规划算法如何实现排课

### 分治、贪心、动态规划的区别：

分治法是指将问题划分成一些独立地子问题，递归地求解各子问题，然后合并子问题的解而得到原问题的解。与此不同，动态规划适用于子问题独立且重叠的情况，也就是各子问题包含公共的子子问题

适合采用动态规划方法的最优化问题中的两个要素：最优子结构和重叠子问题。

动态规划算法的设计可以分为如下4个步骤：

- 描述最优解的结构
- 递归定义最优解的值
- 按自底向上的方式计算最优解的值
- 由计算出的结果构造一个最优解

贪心算法是使所做的选择看起来都是当前最佳的，期望**通过所做的局部最优选择来产生出一个全局最优解**。贪心算法对大多数优化问题来说能产生最优解，但也不一定总是这样的。

**贪心算法通常是自顶向下地做出贪心选择，不断地将给定的问题实例归约为更小的问题。贪心算法划分子问题的结果，通常是仅存在一个非空的子问题**

爬取教务处的课程信息：[PyQuery](https://blog.csdn.net/qq_30500113/article/details/83783834)

```py
import requests
from pyquery import PyQuery as pq

def get_page(url):
    """发起请求 获得源码"""
    r = requests.get(url)
    r.encoding = 'utf8'
    html = r.text
    return html

def parse(text):
    """解析数据 写入文件"""
    doc = pq(text)
    # 获得每一行的tr标签
    tds = doc('table.table tbody tr.alt').items()
    for td in tds:
        rank = td.find('td:first-child').text()     # 排名
        name = td.find('div').text()  # 大学名称
        city = td.find('td:nth-child(3)').text()    # 城市
        score = td.find('td:nth-child(4)').text()   # 总分
        with open('college.csv', 'a+', encoding='utf8') as f:
            f.write(rank + '\t\t')
            f.write(name + '\t\t')
            f.write(city + '\t\t')
            f.write(score + '\t\t\n')
    print("写入完成")

if __name__ == "__main__":
    url = "http://www.zuihaodaxue.cn/zuihaodaxuepaiming2018.html"
    text = get_page(url)
    parse(text)
```

**应用层**：是通过应⽤进程间的交互来完成特定⽹络应⽤ 是应⽤进程（进程：主机中正在运⾏的程序）间的通信和交互的规则

协议：HTTP DNS SMTP

DNS: 将域名和IP地址相互映射

HTTP：超文本传输协议

**运输层**：负责向两台主机进程之间的通信提供通⽤的数据传输服务。

协议： TCP  UDP

TCP：传输控制协议 提供⾯向连接的，可靠的数据传输服务

UDP： 用户数据协议 提供⽆连接的，尽最⼤努⼒的数据传输服 务（不保证数据传输的可靠性）

**网络层**：在计算机⽹络中进⾏通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信⼦⽹。⽹络层的任务就是选择合适的⽹间路由和交换结点， 确保数据及时传送。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。

在发送数据 时，⽹络层把运输层产⽣的报⽂段或⽤户数据报封装成分组和包进⾏传送。在 TCP/IP 体系结构 中，由于⽹络层使⽤ IP 协议，因此分组也叫 IP 数据报 ，简称 数据报

**数据链路层** 两台主机之间的数据传输，总是在⼀段⼀段的链 路上传送的，这就需要使⽤专⻔的链路层的协议

在两个相邻节点之间传送数据时，数据链路层 将⽹络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每⼀帧包括数据和 必要的控制信息（如同步信息，地址信息，差错控制等）。

**物理层** 物理层(physical layer)的作⽤是实现相邻计算机节点之间⽐特流的透明传送，尽可能屏蔽掉具 体传输介质和物理设备的差异。

![image-20210708145356161](C:\Users\17863\AppData\Roaming\Typora\typora-user-images\image-20210708145356161.png)

<img src="C:\Users\17863\AppData\Roaming\Typora\typora-user-images\image-20210708145513889.png" alt="image-20210708145513889" style="zoom:50%;" />

为什么要三次握⼿ 

三次握⼿的⽬的是建⽴可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，⽽三次握 ⼿最主要的⽬的就是双⽅确认⾃⼰与对⽅的发送与接收是正常的。 

第⼀次握⼿：Client 什么都不能确认；Server 确认了对⽅发送正常，⾃⼰接收正常 

第⼆次握⼿：Client 确认了：⾃⼰发送、接收正常，对⽅发送、接收正常；Server 确认了：对⽅ 发送正常，⾃⼰接收正常 

第三次握⼿：Client 确认了：⾃⼰发送、接收正常，对⽅发送、接收正常；Server 确认了：⾃⼰ 发送、接收正常，对⽅发送、接收正常 所以三次握⼿就能确认双发收发功能都正常，缺⼀不可。

<img src="C:\Users\17863\AppData\Roaming\Typora\typora-user-images\image-20210708145618932.png" alt="image-20210708145618932" style="zoom:50%;" />

TCP如何保证可靠传输：

1. 应⽤数据被分割成 TCP 认为最适合发送的数据块。

2. TCP 给发送的每⼀个包进⾏编号，接收⽅对数据包进⾏排序，把有序数据传送给应⽤层。
3. 校验和： TCP 将保持它⾸部和数据的检验和。这是⼀个端到端的检验和，⽬的是检测数据 在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报⽂段和不确认收 到此报⽂段。
4. TCP 的接收端会丢弃重复的数据。 
5. 流量控制： TCP 连接的每⼀⽅都有固定⼤⼩的缓冲空间，TCP的接收端只允许发送端发送 接收端缓冲区能接纳的数据。当接收⽅来不及处理发送⽅的数据，能提示发送⽅降低发送的 速率，防⽌包丢失。TCP 使⽤的流量控制协议是可变⼤⼩的**滑动窗⼝**协议。 （TCP 利⽤滑 动窗⼝实现流量控制） 
6. 拥塞控制： 当⽹络拥塞时，减少数据的发送。 
7. ARQ协议（自动重传请求（Automatic Repeat-reQuest，ARQ）： 也是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等 待对⽅确认。在收到确认后再发下⼀个分组。 
8. 超时重传： 当 TCP 发出⼀个段后，它启动⼀个定时器，等待⽬的端确认收到这个报⽂段。 如果不能及时收到⼀个确认，将重发这个报⽂段。

TCP的拥塞控制采⽤了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复。



但是这个过程中存在一定的风险，HTTP报文是明文，如果中间被截取的话会存在一些信息泄露的风险。那么在进入TCP报文之前对HTTP做一次加密就可以解决这个问题了。HTTPS协议的本质就是HTTP + SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。
TLS/SSL使用了非对称加密

Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率

<img src="C:\Users\17863\AppData\Roaming\Typora\typora-user-images\image-20210708163538765.png" alt="image-20210708163538765" style="zoom:50%;" />

HTTP协议的⻓连接和短连接，实质上是TCP协议的⻓连接和短连接。

HTTP 是⼀种不保存状态，即⽆状态（stateless）协议。也就是说 HTTP 协议⾃身不对请求和响 应之间的通信状态进⾏保存。那么我们保存⽤户状态呢？Session 机制的存在就是为了解决这个 问题

在服务端保存 Session 的⽅法很多，最常⽤的就是内存和数据库(⽐如是使⽤内存数据库redis保 存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？⼤部分情况下，我们 都是通过在 Cookie 中附加⼀个 Session ID 来⽅式来跟踪。

Cookie 被禁⽤怎么办? 

最常⽤的就是利⽤ URL 重写把 Session ID 直接附加在URL路径的后⾯

Cookie ⼀般⽤来保存⽤户信息 保存已经登录过得⽤户信息，

Session 的 主要作⽤就是通过服务端记录⽤户的状态 购物⻋

URI(Uniform Resource Identifier) 是统⼀资源标志符，可以**唯⼀标识**⼀个资源。 URL(Uniform Resource Location) 是统⼀资源定位符，可以提供该资源的**路径**。它是⼀种具 体的 URI，即 URL 可以⽤来标识⼀个资源，⽽且还指明了如何 locate 这个资源。

 HTTP协议运⾏在TCP之上，所有传输的内容都是明⽂，客户端和服务 器端都⽆法验证对⽅的身份。HTTPS是运⾏在SSL/TLS之上的HTTP协议，SSL/TLS 运⾏在 TCP之上。所有传输的内容都经过加密，加密采⽤对称加密，但对称加密的密钥⽤服务器⽅ 的证书进⾏了⾮对称加密。

> 对称加密：密钥只有⼀个，加密解密为同⼀个密码，且加解密速度快，典型的对称加密 算法有DES、AES等； ⾮对称加密：密钥成对出现（且根据公钥⽆法推知私钥，根据私钥也⽆法推知公钥）， 加密解密使⽤不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称 加密速度᫾慢，典型的⾮对称加密算法有RSA、DSA等。

